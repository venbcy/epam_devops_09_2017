package com.epam.drepin.Shapes;

 class Rectangle_01 extends GeometryShape_01{
// класс Rectangle_01 не абстрактный сначала, а shape абстракный
     // при наследовании мы получили x и y из родительского класса
    // класс метод пронаследовал, но реализации не представил. поэтому если не написать abstract, он подчеркивает
    private int width;
    private int height;
    // поля наверху по дефолту имеют значение null, чтобы задать им значение должен быть
    // использован конструктор, будет принимать значение полей и инициализировать их сразу
     // конструктор должен быть публичным чтобы можно им было пользоваться где угодно
     //у конструкторов название всегда совпадает с названием класса

     public Rectangle_01 (int width, int height) {
         this.width = width;
         this.height = height;
         // без this произошло бы перекрытие имён

     }
     public Rectangle_01 (int width, int height, int x, int y) {
         // у нас в этом классе появились новые поля (width height)
         // поэтому мы добавили этот конструктор который принимает четыре параметра
         // TODO - зачем эти поля (int x, int y) засовывать в базовый класс?
         super(x,y); //вызов конструктора базового класса (сходи в базовый класс и возьми x,y)
         // конструкцией выше пробрасываем x,y чтобы они находились в полях базового класса
         this.width = width;
         this.height = height;
        //после того как добавили еще один rectangle_01 конструктор,
         // первый начал подчеркиваться красным - у нас получилась перегрузка
         // и нет конструктора который бы был без значений в базовом классе

     }

    @Override
    public double calculateSquare_01 (){
        // реализация метода который был задан в интерфейсе
        return width * height;
    }

     @Override
     public String toString() {
         return ("Rectangle " + super.toString()  + " size: " + width + " x " + height);
         //приватные поля, вызывать x и y здесь нельзя просто так
         //super.toString() - у базового класса запускаем toString
         // таким образом заменили getX getY вызовом метода базового класса
     }
 }

